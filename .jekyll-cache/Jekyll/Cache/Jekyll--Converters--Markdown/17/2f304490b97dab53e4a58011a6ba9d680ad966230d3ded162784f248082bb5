I"á)<p><a href="https://en.wikipedia.org/wiki/Prefix_sum">Prefix Sum</a> problem is to compute the sum of all the previous elements in an array. Specifically, <em>exclusive prefix sum</em> would compute all the strictly previous (self-exclusive) elements. For example,</p>

<table>
  <thead>
    <tr>
      <th>Input</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Output</td>
      <td>0</td>
      <td>1</td>
      <td>3</td>
      <td>6</td>
      <td>10</td>
    </tr>
  </tbody>
</table>

<h2 id="parallel-scan">Parallel Scan</h2>

<p>The parallel algorithm to solve this is called <em>parallel scan</em>. It can be generalized to more commutative operators with an identity, such as multiplication, and, etc. It consists of two phases: <em>upsweep</em> and <em>downsweep</em>.</p>

<p><em>upsweep</em> is to add the element to the other element that is $2^p$ away from it. For simplicity, the edge check is omitted.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">upsweep</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>downsweep</em> is similar to <em>upsweep</em>, except that it will swap the element that was $2^p$ away to the current element.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">downsweep</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For simplicity, letâ€™s assume the length of array is magnitude of 2. If not, we can always allocate a larger array, with the rest of it wasted. Hereâ€™s the pseudo code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume |a| has length 1 &lt;&lt; q.</span>
<span class="kt">void</span> <span class="nf">prefix_sum</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">;</span>
  
  <span class="c1">// Upsweep phase</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">parallel_for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">-</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">upsweep</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// Reset the last element</span>
  <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="c1">// Downsweep phase</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">parallel_for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">downsweep</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="example">Example</h2>

<p>The following is an example of exclusive sum from 0 to 7. The first column is <code class="language-plaintext highlighter-rouge">d</code> and <code class="language-plaintext highlighter-rouge">dd</code>, where <code class="language-plaintext highlighter-rouge">d</code> is the distance within a sweep, and <code class="language-plaintext highlighter-rouge">dd</code> is the distance for the next sweep. The elements that are filled are those being updated.</p>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(1, 2)</td>
      <td>Â </td>
      <td>1</td>
      <td>Â </td>
      <td>5</td>
      <td>Â </td>
      <td>9</td>
      <td>Â </td>
      <td>13</td>
    </tr>
    <tr>
      <td>(2, 4)</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>6</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>22</td>
    </tr>
    <tr>
      <td>(4, 8)</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>28</td>
    </tr>
    <tr>
      <td>Â </td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>6</td>
      <td>4</td>
      <td>9</td>
      <td>6</td>
      <td>0</td>
    </tr>
    <tr>
      <td>(4, 8)</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>0</td>
      <td>Â </td>
      <td>Â </td>
      <td>Â </td>
      <td>6</td>
    </tr>
    <tr>
      <td>(2, 4)</td>
      <td>Â </td>
      <td>0</td>
      <td>Â </td>
      <td>1</td>
      <td>Â </td>
      <td>6</td>
      <td>Â </td>
      <td>15</td>
    </tr>
    <tr>
      <td>(1, 2)</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>3</td>
      <td>6</td>
      <td>10</td>
      <td>15</td>
      <td>21</td>
    </tr>
  </tbody>
</table>

<h2 id="analysis">Analysis</h2>

<p>See <a href="https://en.wikipedia.org/wiki/Analysis_of_parallel_algorithms">wiki</a> for definition of <em>span</em> and <em>work</em>. The <em>span</em> of the algorithm is $O(\log N)$. In other words, given infinite number of processors, the algorithm can finish in $O(\log N)$ steps. The <em>work</em> is $O(N \log N)$. In other words, given only one processor, the algorithm needs $O(N \log N)$ steps.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li>Kayvonâ€™s <a href="http://15418.courses.cs.cmu.edu/spring2016/lecture/exclusivescan">note</a>.</li>
  <li>15418 <a href="http://15418.courses.cs.cmu.edu/spring2016/article/4">handout</a>; search for <em>Exclusive Prefix Sum</em>.</li>
  <li>My <a href="https://github.com/misaka-10032/PP/blob/master/assignment2/scan/scan.cu">homework</a>.</li>
</ul>
:ET