I"`f<p><a href="https://en.wikipedia.org/wiki/Shadow_mapping">Shadow mapping</a> is a technique to simulate shadows. The basic version could create hard shadows. The advanced versions could even create soft shadows, and look very real. This article walks through some basics, and the demo comes <a href="https://github.com/misaka-10032/shadow-playground">here</a>.</p>

<h2 id="basics">Basics</h2>

<p>Shadowmap builds on top of projections, so let’s briefly review them.</p>

<h3 id="perspective-projection">Perspective Projection</h3>

<p>Perspective projection maps a view frustum to unit cube (or <a href="https://computergraphics.stackexchange.com/a/1771">NDC</a>, <a href="http://15462.courses.cs.cmu.edu/fall2016/lecture/texture/slide_018">figure</a>). If we describe the view frustum with $x_{-1}$, $x_1$, $y_{-1}$, $y_1$, $z_{-1}$, $z_1$, then the matrix could be written as</p>

\[\begin{pmatrix}
-\frac{2z_{-1}}{x_1 - x_{-1}} &amp; 0 &amp; \frac{x_1 + x_{-1}}{x_1 - x_{-1}} &amp; 0 \\
0 &amp; -\frac{2z_{-1}}{y_1 - y_{-1}} &amp; \frac{y_1 + y_{-1}}{y_1 - y_{-1}} &amp; 0 \\
0 &amp; 0 &amp; -\frac{z_1 + z_{-1}}{z_1 - z_{-1}} &amp; \frac{2z_1 z_{-1}}{z_1 - z_{-1}} \\
0 &amp; 0 &amp; -1 &amp; 0
\end{pmatrix}\]

<p>Notice that $0 &lt; z_{-1} &lt; z_1$, because the camera looks at $-z$ by convention.</p>

<h3 id="orthogonal-projection">Orthogonal Projection</h3>

<p>Orthogonal projection maps a cuboid to unit cube (or <a href="https://computergraphics.stackexchange.com/a/1771">NDC</a>, <a href="http://songho.ca/opengl/files/gl_projectionmatrix02.png">figure</a>). If we describe the cuboid with $x_{-1}$, $x_1$, $y_{-1}$, $y_1$, $z_{-1}$, $z_1$, then the matrix could be written as</p>

\[\begin{pmatrix}
\frac{2}{x_1 - x_{-1}} &amp; 0 &amp; 0 &amp; -\frac{x_1 + x_{-1}}{x_1 - x_{-1}} \\
0 &amp; \frac{2}{y_1 - y_{-1}} &amp; 0 &amp; -\frac{y_1 + y_{-1}}{y_1 - y_{-1}} \\
0 &amp; 0 &amp; \frac{2}{z_1 - z_{-1}} &amp; -\frac{z_1 + z_{-1}}{z_1 - z_{-1}} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]

<p>The convention of $0 &lt; z_{-1} &lt; z_1$ also applies here.</p>

<h3 id="model-view-projection">Model, View, Projection</h3>

\[x' = P \cdot V \cdot M \cdot x\]

<p>$M$ puts $x$ in the world coordinate; it’s just a combination of translation and rotation. $V$ puts $Mx$ in the camera coordinate; besides translation and rotation, it also applies a reflection, so that the camera looks at $-z$ direction. $P$ maps $VMx$ to a unit cube; the points with smaller $z$ will occlude those with larger ones.</p>

<h3 id="glm">GLM</h3>

<p><a href="https://glm.g-truc.net/0.9.8/index.html">GLM</a> (and the js version <a href="https://humbletim.github.io/glm-js/">here</a>) provides helper functions to create the matrices we need. For example, if we want to put the model at $(0, 0, 2)$, we could simply say</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">M</span> <span class="o">=</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">glm</span><span class="p">.</span><span class="nx">mat4</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</code></pre></div></div>

<p>One thing to take in mind is that the order of the GLM transform functions that are applied is different from the matrix order. In math, the transform can be represented as <em>left</em> multiplication of a matrix. For example, if we want to rotate (R) then translate (T), then the combinition would be $TR$. However, when it’s expressed in GLM, it will be</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">glm</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span><span class="nx">glm</span><span class="p">.</span><span class="nx">translate</span><span class="p">(...),</span> <span class="p">...);</span>
</code></pre></div></div>

<p>A nice explanation of <a href="https://glm.g-truc.net/0.9.2/api/a00245.html#ga2d6b6c381f047ea4d9ca4145fed9edd5">lookAt</a> can be found <a href="https://stackoverflow.com/a/21830596">here</a>. The main confusion to me came from <code class="language-plaintext highlighter-rouge">center</code> and <code class="language-plaintext highlighter-rouge">up</code>. <code class="language-plaintext highlighter-rouge">center</code> is a reference point in the direction that the eye (or camera) is looking at. Whatever point on this direction could be chosen; the implementation will compute the normalized direction anyway. The choice of <code class="language-plaintext highlighter-rouge">up</code> is also not unique. It doesn’t have to be perpendicular to the direction of your sight; the implementation will find a true up direction perpendicular to the sight. The purpose of passing in this argument is just to prevent showing the world up side down.</p>

<p>Therefore, if we want to put a camera at original, looking at $z$ direction, we could find whatever point as reference point (e.g. <code class="language-plaintext highlighter-rouge">glm.vec3(0, 0, 1)</code>), pick whatever direction that is up (e.g. <code class="language-plaintext highlighter-rouge">glm.vec3(0, 1, 0)</code>), and say</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">V</span> <span class="o">=</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span><span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>After applying <code class="language-plaintext highlighter-rouge">V</code>, the transform would put the center of the world at $-z$ axis, with the camera looking towards it.</p>

<p>For perspective projection, GLM only provides <a href="https://glm.g-truc.net/0.9.2/api/a00245.html#ga1bb3652e43f824d8c1dd5b9e60c80437">function</a> for symetric perspective-view frustum (i.e. $x_{-1} = -x_1$, $y_{-1} = -y_1$). The parameters include</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fovy</code>: see <a href="https://i.stack.imgur.com/nRgAD.png">figure</a>; it’s in radian.</li>
  <li><code class="language-plaintext highlighter-rouge">aspect</code>: <code class="language-plaintext highlighter-rouge">w/h</code>, aka $(x_1 - x_{-1}) / (y_1 - y_{-1})$.</li>
  <li><code class="language-plaintext highlighter-rouge">zNear</code>: $-z_{-1}$.</li>
  <li><code class="language-plaintext highlighter-rouge">zFar</code>: $-z_1$.</li>
</ul>

<p>You may want to pick the proper parameters, so the object is not clipped.</p>

<h2 id="basic-scene">Basic Scene</h2>

<p>To illustrate the shadow mapping, let’s draw a basic scene first: put a small cube on a flat cuboid.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">center</span> <span class="o">=</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">modelMatrix</span> <span class="o">=</span>
    <span class="nx">glm</span><span class="p">.</span><span class="nx">rotate</span><span class="p">(</span>
        <span class="nx">glm</span><span class="p">.</span><span class="nx">translate</span><span class="p">(</span><span class="nx">glm</span><span class="p">.</span><span class="nx">mat4</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">center</span><span class="p">),</span>
        <span class="cm">/* angle= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">radians</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
        <span class="cm">/* axis= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">viewMatrix</span> <span class="o">=</span>
    <span class="nx">glm</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span>
        <span class="cm">/* eye= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">center</span><span class="p">,</span>
        <span class="cm">/* up= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="kd">const</span> <span class="nx">projMatrix</span> <span class="o">=</span>
    <span class="nx">glm</span><span class="p">.</span><span class="nx">perspective</span><span class="p">(</span>
        <span class="cm">/* fovy= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">radians</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
        <span class="cm">/* aspect= */</span> <span class="mi">4</span><span class="p">.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>
        <span class="cm">/* zNear= */</span> <span class="mi">10</span><span class="p">,</span>
        <span class="cm">/* zFar= */</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/images/20180113/basic-scene.png" alt="" /></p>

<h2 id="shadow-mapping">Shadow Mapping</h2>

<p>The basic shadow mapping consists of two passes: the depth pass and the shadow pass. In the depth pass, we compute the depth map of the scene in the view of light, and in the shadow pass, we do a depth test to see if the point is in shadow or not.</p>

<h3 id="depth-pass">Depth Pass</h3>

<p>To compute the depth in the view of light, the logic of computing model, view, projection matrices could be reused. For example, if we want to put a light bulb at <code class="language-plaintext highlighter-rouge">(0, 10, 26)</code>, it’s equivalent to putting a pinhole camera there. If it were directional light, the projection matrix also needs to be replaced with orthogonal projection matrix.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">viewMatrix</span> <span class="o">=</span>
    <span class="nx">glm</span><span class="p">.</span><span class="nx">lookAt</span><span class="p">(</span>
        <span class="cm">/* eye= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="nx">center</span><span class="p">,</span>
        <span class="cm">/* up= */</span> <span class="nx">glm</span><span class="p">.</span><span class="nx">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>Vertex shader</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">attribute</span> <span class="kt">vec3</span> <span class="n">aPos</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">uLightMVP</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">uLightMVP</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Fragment shader</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">precision</span> <span class="kt">mediump</span> <span class="kt">float</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">zzz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/20180113/depth-map.png" alt="" /></p>

<p>Take in mind that <code class="language-plaintext highlighter-rouge">gl_FragCoord.z</code> is in the range of <code class="language-plaintext highlighter-rouge">[0, 1]</code>. Later when we compare <code class="language-plaintext highlighter-rouge">fragmentLightDist</code> and <code class="language-plaintext highlighter-rouge">occluderLightDist</code>, we must make sure they are in the same measure space.</p>

<h3 id="shadow-pass">Shadow Pass</h3>

<p>In the shadow pass, we need to do the depth test, and give the fragments in the shadow less intensity. We would still render the scene in the perspective of the camera. That being said, for each fragment $x$, we will compute its <code class="language-plaintext highlighter-rouge">gl_Position</code> in the unit cube given the view matrix $V_c$ and the projection matrix $P_c$.</p>

\[x_c = P_c V_c M x\]

<p>Now let’s do the depth test. On one hand, for a light source with view matrix $V_l$ and projection matrix $P_l$, its position in the eye of light is</p>

\[x_l = P_l V_l M x\]

<p>On the other hand, the first occluder between this fragment and the light is encoded in the depth map computed in the previous pass. Let’s say the occluder is $y$; in the previous pass we know</p>

\[y_l = P_l V_l M y\]

<p>and have put them in the depth map $Y_l$. If we say $y_l=(y_l^1, y_l^2, y_l^3, 1)^T$, then we can easily look up the depth $y_l^3$ by reading $Y_l[y_l^1][y_l^2]$. If we put $Y_l$ in a frame buffer, and bind it with a texture, we can easily sample $(y_l^1, y_l^2)$ from it. As $x_l$ and $y_l$ are on the same ray of light, $(x_l^1, x_l^2) = (y_l^1, y_l^2)$. Therefore, the depth of the cloest occluder to the light can also be looked up via $Y_l[x_l^1][x_l^2]$.</p>

<p>To put it in shaders, the vertex shader needs to compute $x_c$ and $x_l$ for each $x$.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">mat4</span> <span class="n">kBias</span> <span class="o">=</span> <span class="kt">mat4</span><span class="p">(</span>
    <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span>
    <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>

<span class="k">attribute</span> <span class="kt">vec4</span> <span class="n">aPos</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">uCameraMVP</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">uLightMVP</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec4</span> <span class="n">vLightCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">uCameraMVP</span> <span class="o">*</span> <span class="n">aPos</span><span class="p">;</span>
  <span class="n">vLightCoord</span> <span class="o">=</span> <span class="n">kBias</span> <span class="o">*</span> <span class="n">uLightMVP</span> <span class="o">*</span> <span class="n">aPos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The fragment shader needs to do the depth test and add shadow for the occluded fragments.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">uDepthMap</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec4</span> <span class="n">vLightCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">vec4</span> <span class="n">lightCoord</span> <span class="o">=</span> <span class="n">vLightCoord</span> <span class="o">/</span> <span class="n">vLightCoord</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">fragmentLightDist</span> <span class="o">=</span> <span class="n">lightCoord</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">occluderLightDist</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span><span class="n">uDepthMap</span><span class="p">,</span> <span class="n">lightCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fragmentLightDist</span> <span class="o">&gt;</span> <span class="n">occluderLightDist</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The fragment is behind the occlucer, so it's in the shadow.</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that we need to apply a <code class="language-plaintext highlighter-rouge">kBias</code> besides <code class="language-plaintext highlighter-rouge">uLightMVP</code>. That’s for ease of texture sampling, and also guarantees that the depth range is the same as was computed before in the depth pass. By doing this, we guarantee that <code class="language-plaintext highlighter-rouge">lightCoord.xyz</code>, after normalizing the <code class="language-plaintext highlighter-rouge">w</code> component, are all within the range of <code class="language-plaintext highlighter-rouge">[0, 1]</code>.</p>

<h3 id="depth-map-as-texture">Depth Map as Texture</h3>

<p>This part is WebGL/OpenGL specific. We need to render the depth map as texture, and pass it to the shadow pass. By default, WebGL will render to the canvas, unless we set our own frame buffer. Here’s one caveat for frame buffer: it does <a href="https://gamedev.stackexchange.com/a/72435">not</a> have depth attachment by default, so the depth test won’t work. We could get some faces missing in the framebuffer, while in the canvas everything works fine. Therefore, we need to add the following</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">renderbuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createRenderbuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindRenderbuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span> <span class="nx">renderbuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">renderbufferStorage</span><span class="p">(</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_COMPONENT16</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">framebuffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createFramebuffer</span><span class="p">();</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">bindFramebuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span> <span class="nx">framebuffer</span><span class="p">);</span>
<span class="nx">gl</span><span class="p">.</span><span class="nx">framebufferRenderbuffer</span><span class="p">(</span>
    <span class="nx">gl</span><span class="p">.</span><span class="nx">FRAMEBUFFER</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_ATTACHMENT</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">RENDERBUFFER</span><span class="p">,</span> <span class="nx">renderbuffer</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="shadow-acne">Shadow Acne</h3>

<p>If we simply check the fragment-light distance vs the occluder-light distance, we would get something like this</p>

<p><img src="/images/20180113/shadow-acne.png" alt="" /></p>

<p>It’s known as <a href="https://computergraphics.stackexchange.com/a/2193">shadow acne</a>. It happens because the pre-computed depth map is descrete, and there will be some belt regions where the fragment-light distance is farther in the descrete space, but the actual distance in the continuous space is closer. A simple workaround is to apply a bias on distance to digest the descrete error.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">fragmentLightDist</span> <span class="o">&gt;</span> <span class="nx">occluderLightDist</span> <span class="o">+</span> <span class="nx">kEps</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Apply kEps' bias to digest the error.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/images/20180113/basic-shadow.png" alt="" /></p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="http://15462.courses.cs.cmu.edu/fall2016/lecture/transforms">Lecture</a> on transforms.</li>
  <li>Slide <a href="http://15462.courses.cs.cmu.edu/fall2017/lecture/perspectivetexture/slide_016">16</a> and <a href="http://15462.courses.cs.cmu.edu/fall2017/lecture/perspectivetexture/slide_019">19</a> on perspective projection.</li>
  <li><a href="http://songho.ca/opengl/gl_projectionmatrix.html">Notes</a> on projection.</li>
  <li><a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-model-view-and-projection-matrices">Tutorial</a> on model, view, projection.</li>
  <li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutorial</a> on shadow mapping.</li>
</ul>
:ET