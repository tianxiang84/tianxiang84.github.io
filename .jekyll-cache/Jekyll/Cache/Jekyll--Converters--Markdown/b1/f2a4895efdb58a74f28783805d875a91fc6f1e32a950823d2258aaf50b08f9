I"Å<ul>
  <li>Able to
    <ul>
      <li>Answer sum query within interval.</li>
      <li>Update within fixed-size array.</li>
    </ul>
  </li>
  <li>Variant
    <ul>
      <li>Answer prefix query of min/max.</li>
    </ul>
  </li>
  <li><a href="https://github.com/misaka-10032/alg/blob/master/alg/tree/bit.py">Code</a></li>
</ul>

<h2 id="example">Example</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   _____ 0 _________________________
  /   |     |       \               \
 1    2     4        8         ____ 16 ____               (1 bit)
      |    / \     / | \      /   |     |   \
      3   5   6   9  10 12   17   18    20   24           (2 bits)
              |      |  | \       |     | \
              7     11  13 14     19    21 22             (3 bits)
                           |               |
                           15              23             (4 bits)
</code></pre></div></div>

<h2 id="tree-structure">Tree structure</h2>

<ul>
  <li>Each node takes index as key.</li>
  <li><code class="language-plaintext highlighter-rouge">i</code>th level contains indices with <code class="language-plaintext highlighter-rouge">i</code> bits, e.g.
    <ul>
      <li>First layer has 1(1), 2(10), 4(100), 8(1000).</li>
      <li>Second layer has 3(11), 5(101), 6(110), 9(1001), 10(1010).</li>
      <li>Third layer has 7(111), 11(1011).</li>
    </ul>
  </li>
  <li>Partial prefix sums are computed and stored in nodes.</li>
</ul>

<h2 id="range-of-node">Range of node</h2>

<ul>
  <li>Prefix sums does NOT all start from <code class="language-plaintext highlighter-rouge">i=0</code></li>
  <li>For a current node <code class="language-plaintext highlighter-rouge">c</code> and its parent <code class="language-plaintext highlighter-rouge">p</code>, it computes sum within <code class="language-plaintext highlighter-rouge">[p, c)</code></li>
  <li>For example, <code class="language-plaintext highlighter-rouge">6</code> has parent <code class="language-plaintext highlighter-rouge">4</code>, so this node stores sum within <code class="language-plaintext highlighter-rouge">[4, 6)</code></li>
</ul>

<h2 id="compute-prefix-sum">Compute prefix sum</h2>

<ul>
  <li>Find the leaf node and sum up till root</li>
  <li>e.g. To compute <code class="language-plaintext highlighter-rouge">[0, 7)</code>
    <ul>
      <li>Sum up node 7, 6, 4.</li>
      <li>Rationale is that [0, 7) = [000, 100) + [100, 110) + [110, 111)</li>
    </ul>
  </li>
</ul>

<h2 id="find-parent">Find parent</h2>

<ul>
  <li>Easy way to tell parent is to flip the right most 1, e.g.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">11 = (1011)_2  --&gt;  (1010)_2 = 10</code></li>
      <li><code class="language-plaintext highlighter-rouge">10 = (1010)_2  --&gt;  (1000)_2 = 8</code></li>
    </ul>
  </li>
  <li>Hereâ€™s a quicker way to find parent
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x - (x &amp; -x)</code></li>
      <li>As we know <code class="language-plaintext highlighter-rouge">-x</code> is <code class="language-plaintext highlighter-rouge">~x+1</code></li>
      <li><code class="language-plaintext highlighter-rouge">&amp;</code>ing that with original will only remain the rightmost <code class="language-plaintext highlighter-rouge">1</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="update-value">Update value</h2>

<ul>
  <li>When value of some index is updated, multiple nodes need to be updated.</li>
  <li>Find the leaf interval and the other intervals that contains this interval.
    <ul>
      <li>Only two levels are affected.</li>
      <li>One is the current level, all the right siblings are affected.</li>
      <li>The other one is the first level, all the stems on the right are affected.</li>
    </ul>
  </li>
  <li>e.g. When 8 is updated,
    <ul>
      <li>The leaf interval is like <code class="language-plaintext highlighter-rouge">[?, 1001)</code>, so node 9 is first found.</li>
      <li>Itâ€™s right sibling includes <code class="language-plaintext highlighter-rouge">1010 [8, 10)</code>, <code class="language-plaintext highlighter-rouge">1100 [8, 12)</code>.</li>
      <li>Itâ€™s right ancestors includes <code class="language-plaintext highlighter-rouge">10000 [0, 16)</code>, <code class="language-plaintext highlighter-rouge">100000 [0, 32)</code>, â€¦</li>
    </ul>
  </li>
</ul>

<h2 id="find-next">Find next</h2>

<ul>
  <li>Easy way to find next is to add the right most 1, e.g.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">1001 + 0001 = 1010</code> (next sibling)</li>
      <li><code class="language-plaintext highlighter-rouge">1010 + 0010 = 1100</code> (next sibling)</li>
      <li><code class="language-plaintext highlighter-rouge">1100 + 0100 = 10000</code> (next ancestor)</li>
    </ul>
  </li>
</ul>

<h2 id="initialize">Initialize</h2>

<ul>
  <li>Init the array of the same size with all 0â€™s, whose BIT is also all zeros.</li>
  <li>Update values one by one.</li>
</ul>
:ET