I"è<h3 id="problem-description">Problem Description</h3>
<p>In this exercise, I would like apply the Dynamic Mode Decomposition (DMD) algorithm on a simple problem to familiarize myself with DMD. I will first generate the evolution history of a 2D oscillating system. I will then embed the 2D dynamics into a 3D space (put a planar curve into a 3D space) and corrupt the 3D signal with noise. The noisy 3D data will be fed into the DMD algorithm. I want to see if I can recover the true 2D dynamics from the corrupted 3D signal. The code below is written in MATLAB. I created the toy problem myself and modified the DMD codes in ref 1 to make it work for the problem.</p>

<!--more-->
<h3 id="data-creation">Data Creation</h3>
<p>In this session, I would like to create some 3D noisy data for a 2D dynamical system:
\begin{equation}
  \frac{d z_1}{dt} = - 4 \pi z_2,
\end{equation}
\begin{equation}
  \frac{d z_2}{dt} = \pi z_1
\end{equation}</p>

<pre>
  <code class="matlab">
% create data
t = 0:0.005:5;
z1 = 2.0 * cos(2.0*pi*t);
z2 = 1.0 * sin(2.0*pi*t);
Z = [z1; z2];
%plot(z1,z2); hold on;

W = [sqrt(2.0)/2.0, -sqrt(2.0)/2.0; sqrt(2.0)/2.0, sqrt(2.0)/2.0];
Y = W*Z;
y1 = Y(1,:);
y2 = Y(2,:);
%plot(y1,y2); hold on;

X = [Y; zeros(1,length(y1))];
x1 = X(1,:) + normrnd(0.0,0.01, 1,length(y1));
x2 = X(2,:) + normrnd(0.0,0.01, 1,length(y1));
x3 = X(3,:) + normrnd(0.0,0.01, 1,length(y1));
X = [x1;x2;x3];
%figure; plot3(x1,x2,x3); hold on; axis equal; grid on;

X(1,:) = movmean(X(1,:),5);
X(2,:) = movmean(X(2,:),5);
X(3,:) = movmean(X(3,:),5);

xIndex=1:1:length(x1)-1;
Xp = X(:,xIndex+1);
X = X(:,xIndex);
  </code>
</pre>
<p>In the MATLAB code above, the variable $z$ represents a 2D dynamics. The variable $y$ is a rotation of $z$, which is then embedded into the 3D variable $x$. Finally, some noise is added to $x$ to corrupt the signal. The data is visualized in the plot below. It is a 2D ellipse in a 3D space.
<img src="/images/DMD/DMD_raw_data.png" /></p>

<h3 id="step-1-find-the-reduced-order-space">Step 1: Find the Reduced Order Space</h3>
<p>In this session, we will use SVD to find a reduced order space for the 3D signal. Here the reduced order $r=2$ is assumed to be known. Ref. 1 gives a procedure to determine the optimal order. For this exercise, I want to focus on the DMD algorithm itself so will take a shortcut here.</p>

<pre>
  <code class="matlab">
    [U, Sigma, V] = svd(X,'econ');
    r = 2;
    Ur = U(:,1:r);
    Sigmar = Sigma(1:r,1:r);
    Vr = V(:,1:r);
  </code>
</pre>
<p>Note here the subspace is determined by $\textbf{X}$ and has nothing to do with the matrix $\textbf{X}‚Äô$. If you check the matrix $\textbf{Ur}$, you will find SVD correctly get the reduced state space for us. For me, the $\textbf{Ur}$ matrix is:</p>
<pre>
  <code class="matlab">
    Ur = [-0.7075, 0.7067; -0.7067, -0.7075; -0.0002, -0.0001];
  </code>
</pre>
<p>Next we will need to learn the dynamics from data in this reduced space.</p>

<h3 id="step-2-find-the-dynamics-in-the-reduced-order-space">Step 2: Find the Dynamics in the Reduced Order Space</h3>
<p>We will use SVD to learn the 2D dynamics in the learnt reduced space.</p>
<pre>
  <code class="matlab">
  Atilde = Ur'*Xp*Vr/Sigmar;
  [West, Lambda] = eig(Atilde);
  </code>
</pre>
<p>Here $\tilde{A}$ represents the linear dynamics in the reduced order space, i.e., we learn from the data that the $y$ state evolves as $\vec{y}‚Äô = \tilde{A} \vec{y}$, or the $k$ step is $\vec{y}(k) = \tilde{A}^{k-1} \vec{y}(0)$. In the plot below, the projected raw data on the $y$ space is shown as dots, and the learnt dynamics is shown in a black curve. I can see on the first period, the learnt dynamics matches with the data quite well. But due to numeric error ($\text{det}(\textbf{A})$ is slightly less than $1.0$), in subsequent periodes, our trajectory begins to shrink.
<img src="/images/DMD/DMD_reduced_dym.png" /></p>

<p>The Schur decomposition helps us find the eigen vectors and values for this 2D dynamics.</p>

<h3 id="step-3-recover-the-3d-signal-using-the-2d-dynamics">Step 3: Recover the 3D Signal Using the 2D Dynamics</h3>
<pre>
  <code class="matlab">
  Phi = Xp*(Vr/Sigmar)*West;
  alpha1 = Sigmar*Vr(1,:)';
  b = (West*Lambda)\alpha1;
  
  nc = 100;
  Xest = zeros(3,nc);
  for i=1:1:100
    Xest(:,i) = Phi*(Lambda^(i-1))*b;
  end
  </code>
</pre>

<h3 id="step-4-plotting-the-results">Step 4: Plotting the Results</h3>
<pre>
  <code class="matlab">
  figure;
  plot3(X(1,:),X(2,:),X(3,:),'bo'); hold on;
  plot3(Xest(1,:),Xest(2,:),Xest(3,:),'k-','LineWidth',2.0); hold on;
  </code>
</pre>
<p>If you run the entire code, you will find we succesfully recover a smooth 3D curve using a learnt 2D dynamics. Noise is removed and the 3D data set is digested into a 2D dynamical system.</p>

<h3 id="reference">Reference</h3>
<p>1.Brunton, S. L. &amp; Kutz, J. N. Data-Driven Science and Engineering: Machine Learning, Dynamical Systems, and Control. (Cambridge University Press, 2019). doi:10.1017/9781108380690.</p>
:ET