I"Ê$<h3 id="problem-description">Problem Description</h3>
<p>In this exercise, I would like apply the Dynamic Mode Decomposition (DMD) algorithm on a simple problem to familiarize myself with DMD. I will first generate the evolution history of a 2D oscillating system. I will then embed the 2D dynamics into a 3D space (put a planar curve into a 3D space) and corrupt the 3D signal with noise. The noisy 3D data will be fed into the DMD algorithm. I want to see if I can recover the true 2D dynamics from the corrupted 3D signal. The code below is written in MATLAB. I created the toy problem myself and modified the DMD codes in ref 1 to make it work for the problem.</p>

<!--more-->
<h3 id="data-creation">Data Creation</h3>
<h4 id="a-2d-dynamical-system">A 2D dynamical system</h4>
<p>This first session has nothing to do with the DMD algorithm. The goal is to generate input data. Along the way, I will also try to refresh my memory on how to understand complex-value eigenvectors and eigenvalues for a linear dynamical system, which will help understand the DMD outputs later. Consider the following 2D dynamical system:
\begin{equation}
  \frac{d z_1}{dt} = - 4 \pi z_2,
\end{equation}
\begin{equation}
  \frac{d z_2}{dt} = \pi z_1.
\end{equation}
We will use initial conditions $z_1(0)=2$ and $z_2(0)=0$. The solution to this linear dynamical system is $z_1(t)=2\cos(2\pi t)$ and $z_2(t) = \sin(2\pi t)$. It is a periodic solution with period $T=1.0$ second.</p>
<figure>
  <img src="/images/DMD/DMD_true_2D.png" />
  <figcaption>Fig.1 - Evolution of the 2D dynamical system considered in this exercise.</figcaption>
</figure>

<h4 id="detour-the-eigen-problem">Detour: The eigen problem</h4>
<p>Before generating data for the DMD algorithm, letâ€™s first think about the eigenvectors and eigenvalues for this simple system. Looking at Fig.1, it is clear that there should be no real-value eigenvector-eigenvalue pair for this system. Because if there is such a pair (and letâ€™s denote it as $\vec{v}_z - \lambda_z$), it will satisfy:
\begin{equation}
\frac{d\vec{v}_z}{dt} = \textbf{A}_z \vec{v}_z = \lambda_z \vec{v}_z.
\end{equation}
Geometrically, the above equation says the flow direction $d\vec{v}_z$ is parallel to the state vector $\vec{v}_z$. We know we donâ€™t have such a state because the flow in Fig.1 never points at the origin $z_1 = z_2 = 0$. So we know an eigen calculation will end up with complex-value results.</p>

<p>How should we understand the complex-value eigen results? Letâ€™s say we have an eigenvector $\vec{v}_z = \vec{v}_r + i \vec{v}_i$ and an associated eigenvalue $\lambda_z = \lambda_r + i \lambda_i$. They will satisfy:
\begin{equation}
\frac{d\vec{v}_z}{dt} = \textbf{A}_z \left( \vec{v}_r + i \vec{v}_i \right) = \left(\lambda_r + i \lambda_i\right) \cdot \left( \vec{v}_r + i \vec{v}_i \right).
\end{equation}
Separating the real and imaginary parts, we have:
\begin{equation}
\textbf{A}_z \vec{v}_r = \lambda_r \vec{v}_r - \lambda_i \vec{v}_i,
\end{equation}
and
\begin{equation}
\textbf{A}_z \vec{v}_i = \lambda_r \vec{v}_i + \lambda_i \vec{v}_r.
\end{equation}
If $\lambda_r=0$, we will get:
\begin{equation}
\textbf{A}_z \vec{v}_r = - \lambda_i \vec{v}_i,
\end{equation}
and
\begin{equation}
\textbf{A}_z \vec{v}_i = \lambda_i \vec{v}_r.
\end{equation}
Geometrically, it says when the state is along $\vec{v}_r$, the flow should point along $\vec{v}_i$, and vice versa. This is exactly what Fig. 1 shows us. For example, at any point along the $z_1$ axis, the flow points at the $z_2$ direction. Itâ€™s also clear from the equation that $\lambda_r$ tells us whether the dynamics is winding out ($\lambda_r&gt;1$), converging ($\lambda_r&lt;1$) or following the same orbit again and again ($\lambda_r=1$), while $2\pi/\lambda_i$ gives us the period of the oscillation.</p>

<p>With the above knowledge, it is not surprising that when we perform eigen calculation for our system, we get $\vec{v}_r = [0.8944,0]â€™$, $\vec{v}_i = [0, -0.4472]â€™$, $\lambda_r = 0.0$ and $\lambda_i = 2\pi$.</p>

<p>How do we represent the solution in the eigen space when the eigen results are complex numbers? Letâ€™s make a coordinate transform:
\begin{equation}
\vec{z} = \textbf{W} \vec{v}.
\end{equation}
Here $\textbf{W}$ is the eigenvector matrix. Note that this matrix needs not be orthonormal because there is no guarantee $\textbf{A}_z$ is symmetric. In fact, for our problem, $\textbf{W} \textbf{W}â€™ = \text{diag}\left([1.6, 0.4]\right) \neq \textbf{I}$ (Here $\textbf{W}â€™$ is the complex conjugate transpose). So when we revert the relation, we cannot use the transpose but have to do an inversion:
\begin{equation}
\vec{v} = \textbf{W}^{-1} \vec{z}.
\end{equation}</p>

<p>The transformed $\vec{v}$ should satisfy:
\begin{equation}
\frac{d\vec{v}}{dt} = \left[\textbf{W}^{-1} \textbf{A}_z \textbf{W} \right] \vec{v} = \left[\textbf{W}^{-1} \Lambda \textbf{W} \right] \vec{v} = \Lambda \vec{v}.
\end{equation}</p>

<p>So the solution to $\vec{v}$ is:
\begin{equation}
\vec{v}(t) = \exp \left(\Lambda t\right) \vec{v}(0).
\end{equation}
Here $\exp \left(\Lambda t\right)$ is a diagonal matrix with non-zero elements $\exp (\lambda_i t)$.</p>

<p>Convert the solution back to $\vec{z}$, we can now express $\vec{z}(t)$ as:
\begin{equation}
\vec{z}(t) = \left[ \textbf{W} \exp \left(\Lambda t\right) \textbf{W}^{-1} \right] \vec{z}(0).
\end{equation}</p>

<pre>
  <code class="matlab">
% create data
t = 0:0.005:5;
z1 = 2.0 * cos(2.0*pi*t);
z2 = 1.0 * sin(2.0*pi*t);
Z = [z1; z2];
%plot(z1,z2); hold on;

W = [sqrt(2.0)/2.0, -sqrt(2.0)/2.0; sqrt(2.0)/2.0, sqrt(2.0)/2.0];
Y = W*Z;
y1 = Y(1,:);
y2 = Y(2,:);
%plot(y1,y2); hold on;

X = [Y; zeros(1,length(y1))];
x1 = X(1,:) + normrnd(0.0,0.01, 1,length(y1));
x2 = X(2,:) + normrnd(0.0,0.01, 1,length(y1));
x3 = X(3,:) + normrnd(0.0,0.01, 1,length(y1));
X = [x1;x2;x3];
%figure; plot3(x1,x2,x3); hold on; axis equal; grid on;

X(1,:) = movmean(X(1,:),5);
X(2,:) = movmean(X(2,:),5);
X(3,:) = movmean(X(3,:),5);

xIndex=1:1:length(x1)-1;
Xp = X(:,xIndex+1);
X = X(:,xIndex);
  </code>
</pre>
<p>In the MATLAB code above, the variable $z$ represents a 2D dynamics. The variable $y$ is a rotation of $z$, which is then embedded into the 3D variable $x$. Finally, some noise is added to $x$ to corrupt the signal. The data is visualized in the plot below. It is a 2D ellipse in a 3D space.</p>

<h3 id="step-1-find-the-reduced-order-space">Step 1: Find the Reduced Order Space</h3>
<p>In this session, we will use SVD to find a reduced order space for the 3D signal. Here the reduced order $r=2$ is assumed to be known. Ref. 1 gives a procedure to determine the optimal order. For this exercise, I want to focus on the DMD algorithm itself so will take a shortcut here.</p>

<pre>
  <code class="matlab">
    [U, Sigma, V] = svd(X,'econ');
    r = 2;
    Ur = U(:,1:r);
    Sigmar = Sigma(1:r,1:r);
    Vr = V(:,1:r);
  </code>
</pre>
<p>Note here the subspace is determined by $\textbf{X}$ and has nothing to do with the matrix $\textbf{X}â€™$. If you check the matrix $\textbf{Ur}$, you will find SVD correctly get the reduced state space for us. For me, the $\textbf{Ur}$ matrix is:</p>
<pre>
  <code class="matlab">
    Ur = [-0.7075, 0.7067; -0.7067, -0.7075; -0.0002, -0.0001];
  </code>
</pre>
<p>Next we will need to learn the dynamics from data in this reduced space.</p>

<h3 id="step-2-find-the-dynamics-in-the-reduced-order-space">Step 2: Find the Dynamics in the Reduced Order Space</h3>
<p>We will use SVD to learn the 2D dynamics in the learnt reduced space.</p>
<pre>
  <code class="matlab">
  Atilde = Ur'*Xp*Vr/Sigmar;
  [West, Lambda] = eig(Atilde);
  </code>
</pre>
<p>Here $\tilde{A}$ represents the linear dynamics in the reduced order space, i.e., we learn from the data that the $y$ state evolves as $\vec{y}â€™ = \tilde{A} \vec{y}$, or the $k$ step is $\vec{y}(k) = \tilde{A}^{k-1} \vec{y}(0)$. In the plot below, the projected raw data on the $y$ space is shown as dots, and the learnt dynamics is shown in a black curve. I can see on the first period, the learnt dynamics matches with the data quite well. But due to numeric error ($\text{det}(\textbf{A})$ is slightly less than $1.0$), in subsequent periodes, our trajectory begins to shrink.
<img src="/images/DMD/DMD_reduced_dym.png" /></p>

<p>The Schur decomposition helps us find the eigen vectors and values for this 2D dynamics.</p>

<h3 id="step-3-recover-the-3d-signal-using-the-2d-dynamics">Step 3: Recover the 3D Signal Using the 2D Dynamics</h3>
<pre>
  <code class="matlab">
  Phi = Xp*(Vr/Sigmar)*West;
  alpha1 = Sigmar*Vr(1,:)';
  b = (West*Lambda)\alpha1;
  
  nc = 100;
  Xest = zeros(3,nc);
  for i=1:1:100
    Xest(:,i) = Phi*(Lambda^(i-1))*b;
  end
  </code>
</pre>

<h3 id="step-4-plotting-the-results">Step 4: Plotting the Results</h3>
<pre>
  <code class="matlab">
  figure;
  plot3(X(1,:),X(2,:),X(3,:),'bo'); hold on;
  plot3(Xest(1,:),Xest(2,:),Xest(3,:),'k-','LineWidth',2.0); hold on;
  </code>
</pre>
<p>If you run the entire code, you will find we succesfully recover a smooth 3D curve using a learnt 2D dynamics. Noise is removed and the 3D data set is digested into a 2D dynamical system.</p>

<h3 id="reference">Reference</h3>
<p>1.Brunton, S. L. &amp; Kutz, J. N. Data-Driven Science and Engineering: Machine Learning, Dynamical Systems, and Control. (Cambridge University Press, 2019). doi:10.1017/9781108380690.</p>
:ET