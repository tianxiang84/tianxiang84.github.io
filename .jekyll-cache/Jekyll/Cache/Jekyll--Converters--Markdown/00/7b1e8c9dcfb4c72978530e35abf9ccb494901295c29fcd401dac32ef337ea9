I"®*<p>Having learnt an object file has <code class="language-plaintext highlighter-rouge">.text</code> section for code, <code class="language-plaintext highlighter-rouge">.data</code> section for data, <code class="language-plaintext highlighter-rouge">.bss</code> section for uninitialized data, and so on and so forth, itâ€™s still unclear how itâ€™s mapped into a real ELF file. How an elf file can represent these informations? Through <code class="language-plaintext highlighter-rouge">objdump</code>, we may peek into the content of these sections.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objdump -s obj/boot/boot.out 
</code></pre></div></div>

<p>The result looks like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obj/boot/boot.out:     file format elf32-i386

Contents of section .text:
 7c00 fafc31c0 8ed88ec0 8ed0e464 a80275fa  ..1........d..u.
 7c10 b0d1e664 e464a802 75fab0df e6600f01  ...d.d..u....`..
...

Contents of section .eh_frame:
 7d80 14000000 00000000 017a5200 017c0801  .........zR..|..
 7d90 1b0c0404 88010000 1c000000 1c000000  ................
 
...
</code></pre></div></div>

<p>Itâ€™s misleading for a beginner to look at this directly, because from output it seems that the main contents are interleaved with those headers; however, <strong>they are not</strong>. Now Iâ€™m doing a little mapping how the binary can be interpreted into that way. In fact, the headers locates at the beginning and the end of file; all the data and code in different sections or segments are bunched together in the middle.</p>

<h2 id="tools">Tools</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">readelf</code> (<code class="language-plaintext highlighter-rouge">greadelf</code> for mac, installed by <code class="language-plaintext highlighter-rouge">brew install binutils</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">objdump</code> (<code class="language-plaintext highlighter-rouge">gobjdump</code> for mac)</li>
  <li><a href="http://www.wxhexeditor.org/">wxHexEditor</a></li>
</ul>

<h2 id="file-layout">File layout</h2>

<table border="1" style="margin:auto;">
<tr><td>ELF header</td></tr>
<tr><td>program header</td></tr>
<tr><td>...</td></tr>
<tr><td>program header</td></tr>
<tr><td height="100" align="center">code &amp; data</td></tr>
<tr><td>section header</td></tr>
<tr><td>...</td></tr>
<tr><td>section header</td></tr>
</table>

<h2 id="example">Example</h2>

<p>Take the object file <a href="/images/20151219/boot.out">boot.out</a> for example. You may use <a href="http://www.wxhexeditor.org/">wxHexEditor</a> to peek its raw hex like this.</p>

<p><img src="/images/20151219/wxHexEditor.png" style="width:80%;" /></p>

<p><code class="language-plaintext highlighter-rouge">readelf</code> does a little interpretation on these hexâ€™s.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readelf --all boot.out
</code></pre></div></div>

<p>The result looks like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
...
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
...
</code></pre></div></div>

<h3 id="elf-header">ELF header</h3>

<p>The first part of the file is <code class="language-plaintext highlighter-rouge">ELF header</code>. The most notable characteristic is the magic number <code class="language-plaintext highlighter-rouge">7f 45 4c 46</code>, where <code class="language-plaintext highlighter-rouge">45 4c 46</code> interprets as <code class="language-plaintext highlighter-rouge">ELF</code> in ASCII.</p>

<p><img src="/images/20151219/elf-header.png" style="width:80%;" /></p>

<p>Actually this is the <code class="language-plaintext highlighter-rouge">e_ident</code> field defined by <a href="http://man7.org/linux/man-pages/man5/elf.5.html">struct ElfN_Ehdr</a>. For more detail, please refer to <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia</a>.</p>

<h3 id="program-header-and-section-header">Program header and section header</h3>

<p>The data and code part of a program can be divided into pieces. In a <code class="language-plaintext highlighter-rouge">linker</code>â€™s view, itâ€™s divided into <code class="language-plaintext highlighter-rouge">sections</code>, and the the meta-data of these sections are stored in <code class="language-plaintext highlighter-rouge">section header</code> table (from the figure above we can see itâ€™s located at the end of the file). In <code class="language-plaintext highlighter-rouge">kernel</code>â€™s (executor) view, data and code can be divide into <code class="language-plaintext highlighter-rouge">segments</code>, and the meta-data of them are stored in <code class="language-plaintext highlighter-rouge">program header</code> table.</p>

<p><img src="/images/20151219/sec-seg.png" style="width:60%;" /></p>

<h3 id="section-header-string-table">Section header string table</h3>

<p>Well, its name is a bit long. Actually it is a <code class="language-plaintext highlighter-rouge">section</code> of the file, and it is one of the sources how <code class="language-plaintext highlighter-rouge">objdump</code> know the names of each section. First letâ€™s find it in the raw hex file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readelf --all boot.out
</code></pre></div></div>

<p>and look at this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ELF Header:
  ...
  Start of section headers:          4760 (bytes into file)
  ...
  Size of section headers:           40 (bytes)
  ...
  Section header string table index: 6
  ...
</code></pre></div></div>

<p>It says the start of section headers is 4760, and using this info, <code class="language-plaintext highlighter-rouge">readelf</code> can further interpret the section headers for us (continue on the former result)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  ...
  [ 6] .shstrtab         STRTAB          00000000 001254 000043 00      0   0  1
  ...
</code></pre></div></div>

<p>Actually we may find the <code class="language-plaintext highlighter-rouge">.shstrtab</code> entry ourselves. As from the ELF header we know that the start of section header is 4760, and that size of them is 40, and that the index of <code class="language-plaintext highlighter-rouge">.shstrtab</code> is 6, we can calculate the start of <code class="language-plaintext highlighter-rouge">.shstrtab</code> is $4760 + 6 \times 40 = 5000$.</p>

<p><img src="/images/20151219/entry-shstrtab.png" style="width:80%;" /></p>

<p>Itâ€™s around there. $[5000, 5040)$ of <code class="language-plaintext highlighter-rouge">boot.out</code> maps to <code class="language-plaintext highlighter-rouge">struct Elf32_Shdr</code> (<a href="http://man7.org/linux/man-pages/man5/elf.5.html">ref</a>).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">uint32_t</span>   <span class="n">sh_name</span><span class="p">;</span>
  <span class="kt">uint32_t</span>   <span class="n">sh_type</span><span class="p">;</span>
  <span class="kt">uint64_t</span>   <span class="n">sh_flags</span><span class="p">;</span>
  <span class="n">Elf64_Addr</span> <span class="n">sh_addr</span><span class="p">;</span>
  <span class="n">Elf64_Off</span>  <span class="n">sh_offset</span><span class="p">;</span>
  <span class="kt">uint64_t</span>   <span class="n">sh_size</span><span class="p">;</span>
  <span class="kt">uint32_t</span>   <span class="n">sh_link</span><span class="p">;</span>
  <span class="kt">uint32_t</span>   <span class="n">sh_info</span><span class="p">;</span>
  <span class="kt">uint64_t</span>   <span class="n">sh_addralign</span><span class="p">;</span>
  <span class="kt">uint64_t</span>   <span class="n">sh_entsize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Elf64_Shdr</span><span class="p">;</span>
</code></pre></div></div>

<p>The bytes at 5000 is 0x11, and it should be interpreted into its name, i.e. <code class="language-plaintext highlighter-rouge">.shstrtab</code>. How can? Official explanation is</p>

<blockquote>
  <p>sh_name   This member specifies the name of the section.  Its value is an index into the section header string table section, giving the location of a null-terminated string.</p>
</blockquote>

<p>So thereâ€™s a section <code class="language-plaintext highlighter-rouge">.shstrtab</code> that records all the names of sections. Where is it? Clue is given by this table entry. Letâ€™s look at the interpreted version by <code class="language-plaintext highlighter-rouge">elfread</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  ...
  [ 6] .shstrtab         STRTAB          00000000 001254 000043 00      0   0  1
  ...
</code></pre></div></div>

<p>Offset is 0x1254, size is 0x43, so we will look into [0x1254, 0x1297).</p>

<p><img src="/images/20151219/shstrtab.png" style="width:80%;" /></p>

<p>From the right, we can see that we are finding the right place. Then what does <code class="language-plaintext highlighter-rouge">0x11</code> mean? This index is a bit confusing. Itâ€™s just the index in that char sequence. $0x1254 + 0x11 = 0x1265$, so letâ€™s look at the string starts at 0x1265.</p>

<p><img src="/images/20151219/name-shstrtab.png" style="width:80%;" /></p>

<p>Thatâ€™s correct, <code class="language-plaintext highlighter-rouge">.shstrtab</code>, and that is what we are looking for.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This post looks into some aspects of ELF file format. An example is given to illustrate how <code class="language-plaintext highlighter-rouge">objdump -s</code> may know the locations and names of the sections from it.</p>

<h2 id="references">References</h2>

<ul>
  <li>https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</li>
  <li>http://man7.org/linux/man-pages/man5/elf.5.html</li>
  <li>http://www.opensecuritytraining.info/LifeOfBinaries.html</li>
</ul>

:ET